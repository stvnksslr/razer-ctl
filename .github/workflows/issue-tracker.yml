name: Issue Tracker

on:
  pull_request:
    branches:
      - main

permissions:
  contents: read
  pull-requests: write

jobs:
  track-issues:
    name: Track Issue Changes
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Install beads CLI
        run: |
          curl -fsSL https://raw.githubusercontent.com/steveyegge/beads/main/scripts/install.sh | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Export base branch issues
        run: |
          # Checkout base branch issues.jsonl to temp location
          git show origin/${{ github.base_ref }}:.beads/issues.jsonl > /tmp/base_issues.jsonl 2>/dev/null || echo "" > /tmp/base_issues.jsonl

      - name: Export PR branch issues
        run: |
          # Use bd to export current issues
          bd export --no-db -o /tmp/pr_issues.jsonl 2>/dev/null || cp .beads/issues.jsonl /tmp/pr_issues.jsonl 2>/dev/null || echo "" > /tmp/pr_issues.jsonl

      - name: Analyze issue changes
        id: analyze
        run: |
          # Create indexed maps of issues from both branches using jq
          # Base branch: id -> {status, title}
          if [ -s /tmp/base_issues.jsonl ]; then
            jq -s 'map({(.id): {status: .status, title: .title}}) | add // {}' /tmp/base_issues.jsonl > /tmp/base_map.json
          else
            echo '{}' > /tmp/base_map.json
          fi

          # PR branch: id -> {status, title, close_reason}
          if [ -s /tmp/pr_issues.jsonl ]; then
            jq -s 'map({(.id): {status: .status, title: .title, close_reason: .close_reason}}) | add // {}' /tmp/pr_issues.jsonl > /tmp/pr_map.json
          else
            echo '{}' > /tmp/pr_map.json
          fi

          # Check if this is the first time beads is being added
          base_count=$(jq 'length' /tmp/base_map.json)
          if [ "$base_count" -eq 0 ]; then
            echo "first_time=true" >> $GITHUB_OUTPUT
          else
            echo "first_time=false" >> $GITHUB_OUTPUT
          fi

          # Helper function to format issues hierarchically using collapsible sections
          format_hierarchical() {
            local input_file=$1
            local include_reason=$2

            jq -r --arg include_reason "$include_reason" '
              # Calculate depth based on dot count in ID
              def depth: (split(".") | length) - 1;

              # Get the root/parent ID (everything before first dot, or whole ID if no dot)
              def root_id: split(".")[0];

              # Group issues by their root ID
              group_by(.key | root_id) |

              # Process each group
              map(
                # Sort within group by key
                sort_by(.key) |

                # Check if this is an epic group (has children with dots)
                if (.[0].key | contains(".") | not) and length > 1 then
                  # Epic with children - use collapsible section
                  .[0] as $epic |
                  "<details>\n<summary><strong>\($epic.key)</strong> [\($epic.value.status)]: \($epic.value.title)</summary>\n\n" +
                  (.[1:] | map(
                    (.key | depth) as $d |
                    (if $d == 1 then "- " else "  - " end) as $prefix |
                    if $include_reason == "true" then
                      "\($prefix)`\(.key)` [\(.value.status)]: \(.value.title)<br/>  _Reason: \(.value.close_reason // "No reason provided")_"
                    else
                      "\($prefix)`\(.key)` [\(.value.status)]: \(.value.title)"
                    end
                  ) | join("\n")) +
                  "\n\n</details>"
                elif .[0].key | contains(".") then
                  # Orphan children (parent not in this list) - list normally
                  map(
                    if $include_reason == "true" then
                      "- `\(.key)` [\(.value.status)]: \(.value.title)<br/>  _Reason: \(.value.close_reason // "No reason provided")_"
                    else
                      "- `\(.key)` [\(.value.status)]: \(.value.title)"
                    end
                  ) | join("\n")
                else
                  # Standalone issue (no children)
                  .[0] |
                  if $include_reason == "true" then
                    "- **\(.key)** [\(.value.status)]: \(.value.title)<br/>  _Reason: \(.value.close_reason // "No reason provided")_"
                  else
                    "- **\(.key)** [\(.value.status)]: \(.value.title)"
                  end
                end
              ) | join("\n\n")
            ' "$input_file"
          }

          # Find new issues (in PR but not in base)
          jq -s '
            .[0] as $base | .[1] as $pr |
            $pr | to_entries | map(select(.key as $k | $base[$k] == null))
          ' /tmp/base_map.json /tmp/pr_map.json > /tmp/new_issues.json

          new_count=$(jq 'length' /tmp/new_issues.json)
          format_hierarchical /tmp/new_issues.json "false" > /tmp/new_issues.txt

          # Find closed issues (status changed from open/in_progress to closed)
          jq -s '
            .[0] as $base | .[1] as $pr |
            $pr | to_entries | map(
              select(
                .value.status == "closed" and
                .key as $k | $base[$k] != null and $base[$k].status != "closed"
              )
            )
          ' /tmp/base_map.json /tmp/pr_map.json > /tmp/closed_issues.json

          closed_count=$(jq 'length' /tmp/closed_issues.json)
          format_hierarchical /tmp/closed_issues.json "true" > /tmp/closed_issues.txt

          # Find reopened issues (status changed from closed to open/in_progress)
          jq -s '
            .[0] as $base | .[1] as $pr |
            $pr | to_entries | map(
              select(
                .value.status != "closed" and
                .key as $k | $base[$k] != null and $base[$k].status == "closed"
              )
            )
          ' /tmp/base_map.json /tmp/pr_map.json > /tmp/reopened_issues.json

          reopened_count=$(jq 'length' /tmp/reopened_issues.json)
          format_hierarchical /tmp/reopened_issues.json "false" > /tmp/reopened_issues.txt

          # Build report
          {
            echo "## New Issues Created"
            echo ""
            if [ "$new_count" -gt 0 ]; then
              cat /tmp/new_issues.txt
            else
              echo "_No new issues created_"
            fi
            echo ""
            echo "## Issues Closed"
            echo ""
            if [ "$closed_count" -gt 0 ]; then
              cat /tmp/closed_issues.txt
            else
              echo "_No issues closed_"
            fi
            echo ""
            echo "## Issues Reopened"
            echo ""
            if [ "$reopened_count" -gt 0 ]; then
              cat /tmp/reopened_issues.txt
            else
              echo "_No issues reopened_"
            fi
            echo ""
            echo "---"
            echo "**Summary:** ${new_count} created, ${closed_count} closed, ${reopened_count} reopened"
          } > /tmp/report.md

          # Set outputs
          if [ "$new_count" -gt 0 ] || [ "$closed_count" -gt 0 ] || [ "$reopened_count" -gt 0 ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

          {
            echo 'report<<EOF'
            cat /tmp/report.md
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Comment on PR
        if: steps.analyze.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('/tmp/report.md', 'utf8');
            const firstTime = '${{ steps.analyze.outputs.first_time }}' === 'true';

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('## New Issues Created')
            );

            let body = `# ðŸ“‹ Issue Tracker Report\n\n`;
            if (firstTime) {
              body += `> **Note:** This is the first PR adding beads issue tracking. All issues appear as "new".\n\n`;
            }
            body += report;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
